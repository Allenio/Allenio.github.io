[{"id":"d35aa27c88d9129f36d1edc973a2e52a","title":"JVM JRE JDK的概念","content":"JVM JRE JDK的概念  学习JVM JRE JDK的概念以及相互之间的关系\nJVM是什么？  JVM的全称是Java Virtual Machine，翻译过来就是叫虚拟计算机，它主要负责Java程序的运行。:::tip  边解释、边运行:::  Java程序是在Java虚拟机上直接运行，而不是运行在操作系统上。  Java的跨平台就是基于不同版本的JVM来实现的e.g. 写了一个Java程序，要在Linux系统上运行，首先必须在Linux系统上安装相应版本的JVM后才可运行，如果在macOS上运行写好的Java程序，就要安装macOS版本的JVM，程序最终在Windows版本的JVM上实现运行。Windows同理。\nJRE是什么？  JRE的全称是Java Runtime Environment，Java运行时环境。:::tip JRE是什么？  JRE = JVM + 核心类库和相关文件:::  JRE与JVM是一个包含的关系，JRE里面包含了JVM。\nJDK是什么？  JDK的全称是Java Development Kit，Java开发工具包，提供给开发人员使用。:::tip JDK是什么？  JDK = JRE + Java开发工具:::\nJDK JRE JVM之间的关系是:::tip  JDK = Java开发工具 + JRE（JVM + 相关类库）:::  JVM加相关的类库组成了JRE，JRE加开发工具组成了JDK，三者之间是包含的关系。其中JDK最大、中间是JRE、里边是JVM。\n","slug":"JDK的概念","date":"2021-06-29T10:13:49.000Z","categories_index":"Java","tags_index":"Java学习总结","author_index":"Allen Yang"},{"id":"9978971f2d070c10eec917053c6beae2","title":"利用Hexo搭建blog","content":"利用Hexo搭建blogHexo介绍Hexo是一款快速、简洁且高效的博客框架，Hexo官方网站\nHexo搭建步骤1.安装Git2.安装Node.js3.安装Hexo\n首先安装GitmacOS安装Git，Git官方网站首先安装Howbrew，由于官网命令会报错，所以选择清华源。终端输入命令后，按照提示操作。\n&#x2F;bin&#x2F;zsh -c &quot;$(curl -fsSL https:&#x2F;&#x2F;gitee.com&#x2F;cunkai&#x2F;HomebrewCN&#x2F;raw&#x2F;master&#x2F;Homebrew.sh)&quot;\n安装成功后，安装Git\nbrew install git\n安装成功后创建ssh key、配置git1.设置username和email（github每次commit都会记录他们）\ngit config --global user.name \"username\" //用户名\ngit config --global user.email \"Allen.hx.Yang@gmail.com\" //邮箱\n2.通过终端命令创建ssh key\nssh-keygen -t rsa -C \"Allen.hx.Yang@gmail.com\"\n回车后有以下输出\nLast login: Sat Jan  6 14:12:16 on ttys000\nWMBdeMacBook-Pro:~ WENBO$ ssh-keygen -t rsa -C \"Allen.hx.Yang@gmail.com\"\nGenerating public/private rsa key pair.\nEnter file in which to save the key (/Users/mac/.ssh/id_rsa): \n/Users/mac/.ssh/id_rsa already exists.\nOverwrite (y/n)? \ny以后，会输入一个私密id_rsa密码，最后会生成id_rsa、和id_rsa.pub文件。终端查看.ssh/id_rsa.pub公共密钥\nopen .ssh&#x2F;id_rsa.pub \n复制内容到GitHub–&gt;settings–&gt;SSH and GPG keys–&gt;New SSH key随便填一个title，将key复制进去点Add SSH key最后链接验证\nssh -T git@github.com \n终端输出结果\nLast login: Sat Jan  6 14:42:55 on ttys000\nWMBdeMacBook-Pro:~ WENBO$ ssh -T git@github.com \nHi Allenio! You&#39;ve successfully authenticated, but GitHub does not provide shell access.\nWMBdeMacBook-Pro:~ WENBO$  \n说明已经链接成功\n安装node.jsnode.js官网下载对应版本并安装完成后终端输入\nnpm -v \nnode -v\n出现版本信息，说明安装成功\n安装Hexo安装好git和node.js后，安装Hexo输入命令\nnpm install -g hexo-cli\n完成后用hexo -v查看一下版本是否安装完毕接下来初始化hexo\nhexo init MyBlog\n之后\ncd &#x2F;~MyBlog\nnpm install\n新建完成后就可以配置Hexo了\nhexo clean\nhexo g\nhexo d","slug":"安装hexo","date":"2021-06-28T15:31:36.000Z","categories_index":"配置环境","tags_index":"Hexo","author_index":"Allen Yang"},{"id":"079ca4b962925da31ee3129301d8960d","title":"Git是什么？","content":"Git是什么？&emsp;&emsp;Git是目前世界上最先进的分布式版本控制系统。\n什么是版本控制系统？&emsp;&emsp;能自动帮助记录每次文件的改动，还可以让他人协作编辑。\nGit的诞生&emsp;&emsp;很多人都知道，Linus在1991年创建了开源的Linux，从此，Linux系统不断发展，已经成为最大的服务器系统软件了。\n&emsp;&emsp;Linus虽然创建了Linux，但Linux的壮大是靠全世界热心的志愿者参与的，这么多人在世界各地为Linux编写代码，那Linux的代码是如何管理的呢？\n&emsp;&emsp;事实是，在2002年以前，世界各地的志愿者把源代码文件通过diff的方式发给Linus，然后由Linus本人通过手工方式合并代码！\n&emsp;&emsp;你也许会想，为什么Linus不把Linux代码放到版本控制系统里呢？不是有CVS、SVN这些免费的版本控制系统吗？因为Linus坚定地反对CVS和SVN，这些集中式的版本控制系统不但速度慢，而且必须联网才能使用。有一些商用的版本控制系统，虽然比CVS、SVN好用，但那是付费的，和Linux的开源精神不符。\n&emsp;&emsp;不过，到了2002年，Linux系统已经发展了十年了，代码库之大让Linus很难继续通过手工方式管理了，社区的弟兄们也对这种方式表达了强烈不满，于是Linus选择了一个商业的版本控制系统BitKeeper，BitKeeper的东家BitMover公司出于人道主义精神，授权Linux社区免费使用这个版本控制系统。\n&emsp;&emsp;安定团结的大好局面在2005年就被打破了，原因是Linux社区牛人聚集，不免沾染了一些梁山好汉的江湖习气。开发Samba的Andrew试图破解BitKeeper的协议（这么干的其实也不只他一个），被BitMover公司发现了（监控工作做得不错！），于是BitMover公司怒了，要收回Linux社区的免费使用权。\n&emsp;&emsp;Linus可以向BitMover公司道个歉，保证以后严格管教弟兄们，嗯，这是不可能的。实际情况是这样的：\n&emsp;&emsp;Linus花了两周时间自己用C写了一个分布式版本控制系统，这就是Git！一个月之内，Linux系统的源码已经由Git管理了！牛是怎么定义的呢？大家可以体会一下。\n&emsp;&emsp;Git迅速成为最流行的分布式版本控制系统，尤其是2008年，GitHub网站上线了，它为开源项目免费提供Git存储，无数开源项目开始迁移至GitHub，包括jQuery，PHP，Ruby等等。\n&emsp;&emsp;历史就是这么偶然，如果不是当年BitMover公司威胁Linux社区，可能现在我们就没有免费而超级好用的Git了。\n集中式和分布式集中式版本控制系统&emsp;&emsp;集中式版本控制系统，版本库是集中存放在中央服务器，工作时，用的都是自己的电脑，所以要先从中央服务器取得最新的版本，然后工作完再把做完的推送给中央服务器。ps:中央服务器就好比是一个图书馆，你要改一本书，必须先从图书馆借出来，然后回到家自己改，改完了，再放回图书馆。&emsp;&emsp;集中式版本控制系统最大的毛病就是必须联网才能工作，上传快慢取决于网速。\n分布式版本控制系统&emsp;&emsp;分布式版本控制系统根本没有“中央服务器”，每个人的电脑上都是一个完整的版本库，这样，工作时就不需要联网了，因为版本库就在自己的电脑上。比方说你在自己电脑上改了文件A，你的同事也在他的电脑上改了文件A，这时，你们俩之间只需把各自的修改推送给对方，就可以互相看到对方的修改了。\n&emsp;&emsp;和集中式版本控制系统相比，分布式版本控制系统的安全性要高很多，因为每个人电脑里都有完整的版本库，某一个人的电脑坏掉了不要紧，随便从其他人那里复制一个就可以了。而集中式版本控制系统的中央服务器要是出了问题，所有人都没法干活了。\n&emsp;&emsp;在实际使用分布式版本控制系统的时候，其实很少在两人之间的电脑上推送版本库的修改，因为可能你们俩不在一个局域网内，两台电脑互相访问不了，也可能今天你的同事病了，他的电脑压根没有开机。因此，分布式版本控制系统通常也有一台充当“中央服务器”的电脑，但这个服务器的作用仅仅是用来方便“交换”大家的修改，没有它大家也一样干活，只是交换修改不方便而已。\n&emsp;&emsp;Git的优势不单是不必联网这么简单，后面我们还会看到Git极其强大的分支管理，把SVN等远远抛在了后面。\n","slug":"Git是什么","date":"2021-06-28T10:41:13.000Z","categories_index":"Git","tags_index":"Git学习","author_index":"Allen Yang"},{"id":"b9663f58f18133b35bfe243f3e916a80","title":"Hello World","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.\nQuick StartCreate a new post$ hexo new \"My New Post\"\n\nMore info: Writing\nRun server$ hexo server\n\nMore info: Server\nGenerate static files$ hexo generate\n\nMore info: Generating\nDeploy to remote sites$ hexo deploy\n\nMore info: Deployment\n","slug":"hello-world","date":"2021-06-26T14:26:30.613Z","categories_index":"","tags_index":"","author_index":"Allen Yang"},{"id":"bc67f746267711d34d7d01392a094498","title":"内部类","content":"内部类内部类概述把类定义在其他类的内部,这个类就被称为内部类.eg:在类A中定义类B,类B就是内部类\n内部类的访问特点\n内部类可以直接访问外部类的成员,包括私有.\n外部类要访问内部类的成员,必须创建对象.\n\n内部类位置\n成员位置(成员内部类)\n局部位置(局部内部类)\n\n","slug":"内部类","date":"2019-04-05T01:50:16.000Z","categories_index":"","tags_index":"","author_index":"Allen Yang"},{"id":"7c404b581c0c2649a73faf534a78653e","title":"修饰符","content":"修饰符权限修饰符权限修饰符:private、默认、protected、public\n\n\n\n\n\n本类\n同一包下(子类和无关类)\n不同包下(子类)\n不同包下(无关类)\n\n\n\nprivate\n可以执行\n不能访问\n不能访问\n不能访问\n\n\n默认\n可以执行\n可以执行\n不能访问\n不能访问\n\n\nprotected\n可以执行\n可以执行\n可以执行\n不能访问\n\n\npublic\n可以执行\n可以执行\n可以执行\n可以执行\n\n\n结论:\n\n\n\n\n\n\n\nprivate (本类访问)\n默认 (同一包下访问)\nprotected (子类访问)\npublic (任何地方被访问)\n\n状态修饰符状态修饰符:static、final\n\n抽象修饰符抽象修饰符:abstract\n\n类及其组成所使用的常见修饰符类使用的修饰符权限修饰符:默认修饰符,public状态修饰符:final抽象修饰符:abstract\n用的最多的:public\n成员变量使用的修饰符权限修饰符:private,默认修饰符,protected,public状态修饰符:static,final\n用的最多的 private\n构造方法使用的修饰符权限修饰符:private,默认修饰符,protected,public\n用的最多的:public\n成员方法使用的修饰符权限修饰符:private,默认修饰符,protected,public状态修饰符:static,final抽象修饰符:abstract\n用的最多的:public\n其他的组合规则成员变量:public static final成员方法:public static&emsp;&emsp;&emsp;&emsp; public abstract&emsp;&emsp;&emsp;&emsp; public final\n","slug":"修饰符","date":"2019-04-05T01:44:44.000Z","categories_index":"","tags_index":"","author_index":"Allen Yang"},{"id":"b45a9784be195b1c2a050ed30caafc39","title":"导包练习题","content":"package，import，class有没有顺序关系package&gt;import&gt;classpackage:只能有一个import:可以有多个class:可以有多个，但是建议是一个\n","slug":"导包练习题","date":"2018-12-11T12:22:23.000Z","categories_index":"Java","tags_index":"例题","author_index":"Allen Yang"},{"id":"4dfc24012675b059867bcf499de79b27","title":"package概述及作用","content":"包的概述\n其实就是文件夹\n作用:a:把相同的类名放到不同的包中b:对类进行分类管理\n\neg:学生:增删改查老师:增删改查\n方1:按照功能分\ncn.school.add\n\nAddStudent\nAddTeacher\n\ncn.school.delete\n\nDeleteStudent\nDeleteTeacher\n\ncn.school.update\n\nUpdateStudent\nUpdateTeacher\n\ncn.school.find\n\nFindStudent\nFindTeacher\n\n方2:\ncn.school.teacher\n\nAddTeacher\nDeleteTeacher\nUpdateTeacher\nFindTeacher\n\ncn.school.student\n\nAddStudent\nDeleteStudent\nUpdateStudent\nFindStudent\n\n包的定义及注意事项包的定义package 包名;多级包用.分开\n注意事项\npackage语句必须是程序的第一条可执行的代码\npackage语句在一个java文件中只能有一个\n如果没有package,默认表示无包名\n\n带包的类的编译和运行\n手动a:javac编译当前类文件b:手动建立包对应的文件夹c:把a步骤的class文件放到b步骤的最终文件下d:通过java命令执行.注:需要带包名称执行\n  java cn.school.AddStudent\n\n\n自动a:javac编译的时候带上-d\n  javac -d . Addschool.java\n\nb:通过java命令执行.和手动式一样\n  java cn.school.AddStudent\n\n\n\n导包导包概述不通过包下的类之间的访问，每次使用不同包下的类的时候，都需要加包的全路径，比较麻烦，因此有了导包\n导包格式import 包名;注意：\n\n这种方式导入是到类的名称。\n虽然可以最后写*，但是不建议。（用谁就导谁）\n\n","slug":"package概述及作用","date":"2018-12-11T08:22:23.000Z","categories_index":"Java","tags_index":"Java学习总结","author_index":"Allen Yang"},{"id":"f0dff90444263315eec834dbee6f43a2","title":"形式参数和返回值的问题","content":"形式参数基本类型引用类型:\n\n类名: (需要该类的对象)\nclass Student&#123;\n\tpublic void study()&#123;\n\t\tSystem.out.println(&quot;学习&quot;);\n\t&#125;\n&#125;\n\nclass StudentDemo&#123;\n\tpublic void method(Student s)&#123;&#x2F;&#x2F; ss; ss &#x3D; new Student(); Student s &#x3D; new Student();\n\t\ts.study();\n\t&#125;\n&#125;\n\nclass StudentTest&#123;\n\tpublic static void main(String[] args)&#123;\n\t\tStudent s &#x3D; new Student();\n\t\ts.study();\n\t\tSystem.out.println(&quot;---------&quot;);\n\t\tStudentDemo sd &#x3D; new StudentDemo();\n\t\tStudent ss &#x3D; new Student();\n\t\tsd.method(ss);&#x2F;&#x2F; &#x3D; sd.method(new Student());\n\t\tSystem.out.println(&quot;---------&quot;);\n\t\tnew StudentDemo().method(new Student());&#x2F;&#x2F;匿名对象\n\t&#125;\n&#125;\n抽象类:(抽象类没有对应的具体类时无法使用)(需要该抽象类的子类对象)\nabstract class Person&#123;\n\tpublic abstract void study();\n&#125;\n\nclass PersonDemo&#123;\n\tpublic void method(Person p)&#123;&#x2F;&#x2F; p; p &#x3D; new Student(); Person p &#x3D; new Student(); &#x2F;&#x2F;多态\n\t\tp.study();\n\t&#125;\n&#125;\n\nclass Student extends Person&#123;\n\tpublic void study()&#123;\n\t\tSystem.out.println(&quot;学习&quot;);\n\t&#125;\n&#125;\n\nclass PersonTest&#123;\n\tpublic static void main(String[] args)&#123;\n\t\t&#x2F;&#x2F;抽象类没有对应的具体类时无法使用\n\t\tPersonDemo pd &#x3D; new PersonDemo();\n\t\tPerson p &#x3D; new Student();\n\t\tpd.method(p);\n\t&#125;\n&#125;\n接口:(需要该接口的实现类对象)\ninterface Hobby&#123;\n\tpublic abstract void hobby();\n&#125;\n\nclass hobbyDemo &#123;\n\tpublic void method(Hobby h)&#123;&#x2F;&#x2F; h ; h &#x3D; new Teacher(); Hobby h &#x3D; new Teacher();&#x2F;&#x2F;多态\n\t\th.hobby();\n\t&#125;\n&#125;\n\nclass Teacher implements Hobby&#123;\n\tpublic void hobby()&#123;\n\t\tSystem.out.println(&quot;打麻将&quot;);\n\t&#125;\n&#125;\n\nclass TeacherTest&#123;\n\tpublic static void main(String[] args)&#123;\n\t\t&#x2F;&#x2F;需要具体类实现接口\n\t\thobbyDemo hd &#x3D; new hobbyDemo();\n\t\tHobby h &#x3D; new Teacher();\n\t\thd.method(h);\n\t&#125;\n&#125;\n\n返回值类型基本类型引用类型:\n\n类:(返回的是该类的对象)class Student&#123;\n\tpublic void study()&#123;\n\t\tSystem.out.println(&quot;学习&quot;);\n\t&#125;\n&#125;\n\nclass StudentDemo&#123;\n\tpublic Student getStudent()&#123;\n\t\t&#x2F;&#x2F;Student s &#x3D; new Student();\n\t\t&#x2F;&#x2F;Student ss &#x3D; s;\n\t\t&#x2F;&#x2F;Student s &#x3D; new Student();\n\t\t&#x2F;&#x2F;return s;\n\t\treturn new Student();\n\t&#125;\n&#125;\n\nclass StudentTest&#123;\n\tpublic static void main(String[] args)&#123;\n\t\t&#x2F;&#x2F;不创建student对象 使用studentDemo创建对象\n\t\tStudentDemo sd &#x3D; new StudentDemo();\n\t\tStudent s &#x3D; sd.getStudent();\n\t\ts.study();\n\t&#125;\n&#125;\n抽象类:(返回的是该抽象类的子类对象)abstract class Person&#123;\n\tpublic abstract void study();\n&#125;\n\nclass PersonDemo&#123;\n\tpublic Person getPerson()&#123;\n\t\tPerson p &#x3D; new Student();\n\t\treturn p;\n\t&#125;\n&#125;\n\nclass Student extends Person&#123;\n\tpublic void study()&#123;\n\t\tSystem.out.println(&quot;学习&quot;);\n\t&#125;\n&#125;\n\nclass PersonTest&#123;\n\tpublic static void main(String[] args)&#123;\n\t\tPersonDemo pd &#x3D; new PersonDemo();\n\t\tPerson p &#x3D; pd.getPerson();&#x2F;&#x2F;new Student(); Person p &#x3D; new Student();&#x2F;&#x2F;多态\n\t\tp.study();\n\t&#125;\n&#125;\n接口:(返回该接口的实现类的对象)interface Hobby&#123;\n\tpublic abstract void hobby();\n&#125;\n\nclass hobbyDemo &#123;\n\tpublic Hobby getHobby()&#123;\n\t\treturn new Teacher();\n\t&#125;\n&#125;\n\nclass Teacher implements Hobby&#123;\n\tpublic void hobby()&#123;\n\t\tSystem.out.println(&quot;打麻将&quot;);\n\t&#125;\n&#125;\n\nclass TeacherTest&#123;\n\tpublic static void main(String[] args)&#123;\n\t\thobbyDemo hd &#x3D; new hobbyDemo();\n\t\tHobby h &#x3D; hd.getHobby();\n\t\th.hobby();\n\t&#125;\n&#125;\n\n链式编程特点：每次调用完毕方法后，返回的是一个对象。\nclass Student&#123;\n\tpublic void study()&#123;\n\t\tSystem.out.println(&quot;学习&quot;);\n\t&#125;\n&#125;\n\nclass StudentDemo&#123;\n\tpublic void method(Student s)&#123;&#x2F;&#x2F; ss; ss &#x3D; new Student(); Student s &#x3D; new Student();\n\t\ts.study();\n\t&#125;\n&#125;\n\nclass StudentTest&#123;\n\tpublic static void main(String[] args)&#123;\n\t\tStudentDemo sd &#x3D; new StudentDemo();\n\t\tsd.getStudent().study();&#x2F;&#x2F;链式编程\n\t&#125;\n&#125;","slug":"形式参数和返回值的问题","date":"2018-12-11T01:15:54.000Z","categories_index":"Java","tags_index":"Java学习总结,面向对象","author_index":"Allen Yang"},{"id":"6831cd9b2cda379b7d3cdbe218da0894","title":"运动员与教练练习题","content":"例题概况\n乒乓球运动员和篮球运动员\n乒乓球教练和篮球教练\n为了出国交流,跟乒乓球相关的人员都需要学习英语\n分析 这个案例哪些需要抽象类,哪些接口,哪些具体类\n\n例题分析抽象类：人、运动员、教练具体类：乒乓球运动员、篮球运动员、乒乓球教练、篮球教练接口：学习英语—乒乓球运动员、乒乓球教练\n例题实现abstract class Person&#123;\n\tprivate String name;\n\tprivate int age;\n\tpublic abstract void eat();\n\tpublic void sleep() &#123;\n\t\tSystem.out.println(&quot;睡觉&quot;);\n\t&#125;\n\tpublic String getName() &#123;\n\t\treturn name;\n\t&#125;\n\tpublic void setName(String name) &#123;\n\t\tthis.name &#x3D; name;\n\t&#125;\n\tpublic int getAge() &#123;\n\t\treturn age;\n\t&#125;\n\tpublic void setAge(int age) &#123;\n\t\tthis.age &#x3D; age;\n\t&#125;\n\tpublic Person() &#123;&#125;\n\tpublic Person(String name,int age) &#123;\n\t\tthis.name &#x3D; name;\n\t\tthis.age &#x3D; age;\n\t&#125;\n&#125;\nabstract class Player extends Person&#123;\n\tpublic Player() &#123;&#125;\n\tpublic Player(String name,int age) &#123;\n\t\tsuper(name,age);\n\t&#125;\n\tpublic abstract void study();\n&#125;\nabstract class Coach extends Person&#123;\n\tpublic Coach() &#123;&#125;\n\tpublic Coach(String name,int age) &#123;\n\t\tsuper(name,age);\n\t&#125;\n\tpublic abstract void teach();\n&#125;\n\nclass BasketballPlayer extends Player&#123;\n\tpublic BasketballPlayer() &#123;&#125;\n\tpublic BasketballPlayer(String name,int age) &#123;\n\t\tsuper(name,age);\n\t&#125;\n\tpublic void eat() &#123;\n\t\tSystem.out.println(&quot;篮球运动员吃的多&quot;);\n\t&#125;\n\tpublic void study() &#123;\n\t\tSystem.out.println(&quot;篮球运动员学习新的篮球技巧&quot;);\n\t&#125;\n&#125;\n\nclass PingpangPlayer extends Player implements LearnEnglish&#123;\n\tpublic PingpangPlayer() &#123;&#125;\n\tpublic PingpangPlayer(String name,int age) &#123;\n\t\tsuper(name,age);\n\t&#125;\n\tpublic void eat() &#123;\n\t\tSystem.out.println(&quot;乒乓球运动员吃的少&quot;);\n\t&#125;\n\tpublic void study() &#123;\n\t\tSystem.out.println(&quot;乒乓球运动员学习新的篮球技巧&quot;);\n\t&#125;\n\tpublic void learn() &#123;\n\t\tSystem.out.println(&quot;运动员学习英语&quot;);\n\t&#125;\n&#125;\n\nclass BasketballCoach extends Coach&#123;\n\tpublic BasketballCoach() &#123;&#125;\n\tpublic BasketballCoach(String name,int age) &#123;\n\t\tsuper(name,age);\n\t&#125;\n\tpublic void eat() &#123;\n\t\tSystem.out.println(&quot;篮球教练吃的少&quot;);\n\t&#125;\n\tpublic void teach() &#123;\n\t\tSystem.out.println(&quot;篮球教练教新的战术&quot;);\n\t&#125;\n&#125;\nclass PingpangCoach extends Coach implements LearnEnglish&#123;\n\tpublic PingpangCoach() &#123;&#125;\n\tpublic PingpangCoach(String name,int age) &#123;\n\t\tsuper(name,age);\n\t&#125;\n\tpublic void eat() &#123;\n\t\tSystem.out.println(&quot;乒乓球教练吃的少&quot;);\n\t&#125;\n\tpublic void teach() &#123;\n\t\tSystem.out.println(&quot;乒乓球教练教新的战术&quot;);\n\t&#125;\n\tpublic void learn() &#123;\n\t\tSystem.out.println(&quot;教练学习英语&quot;);\n\t&#125;\n&#125;\ninterface LearnEnglish&#123;\n\tpublic abstract void learn();\n&#125;\n\n\npublic class Test &#123;\n\tpublic static void main(String[] args) &#123;\n\t\tBasketballPlayer bp &#x3D; new BasketballPlayer();\n\t\tbp.setAge(25);\n\t\tbp.setName(&quot;艾弗森&quot;);\n\t\tSystem.out.println(bp.getName()+&quot;是篮球运动员今年&quot;+bp.getAge()+&quot;岁&quot;);\n\t\tbp.eat();\n\t\tbp.sleep();\n\t\tbp.study();\n\t\tSystem.out.println(&quot;-------------------&quot;);\n\t\tBasketballCoach bc &#x3D; new BasketballCoach();\n\t\tbc.setAge(55);\n\t\tbc.setName(&quot;布朗&quot;);\n\t\tSystem.out.println(bc.getName()+&quot;是篮球教练今年&quot;+bc.getAge()+&quot;岁&quot;);\n\t\tbc.eat();\n\t\tbc.sleep();\n\t\tbc.teach();\n\t\tSystem.out.println(&quot;-------------------&quot;);\n\t\tPingpangPlayer pp &#x3D; new PingpangPlayer();\n\t\tpp.setAge(22);\n\t\tpp.setName(&quot;张怡宁&quot;);\n\t\tSystem.out.println(pp.getName()+&quot;是乒乓球运动员今年&quot;+pp.getAge()+&quot;岁&quot;);\n\t\tpp.eat();\n\t\tpp.sleep();\n\t\tpp.study();\n\t\tpp.learn();\n\t\tSystem.out.println(&quot;-------------------&quot;);\n\t\tPingpangCoach pc &#x3D; new PingpangCoach();\n\t\tpc.setAge(43);\n\t\tpc.setName(&quot;刘国梁&quot;);\n\t\tSystem.out.println(pc.getName()+&quot;是乒乓球教练今年&quot;+pc.getAge()+&quot;岁&quot;);\n\t\tpc.eat();\n\t\tpc.sleep();\n\t\tpc.teach();\n\t\tpc.learn();\n\t\tSystem.out.println(&quot;-------------------&quot;);\n\t&#125;\n&#125;\t","slug":"运动员与教练练习题","date":"2018-12-10T12:29:11.000Z","categories_index":"Java","tags_index":"例题","author_index":"Allen Yang"},{"id":"8aba8af17209e23865c30ccb831564d2","title":"接口","content":"接口概述为了体现事物功能的扩展性，Java中就提供了接口来定义这些额外功能，并不给出具体实现。\n接口特点1.接口用关键字interface表示\n\n格式：interface 接口名{}\n\n2.类实现接口用implements表示\n\n格式：class 类名 implements 接口名{}\n\n3.接口不能实例化\n\n可以按照多态的方式来实例化A:具体类多态(几乎没有)B:抽象类多态(常用)C:接口多态(最常用)\n\n4.接口的子类a:可以是抽象类,但是意义不大.b:可以是具体类,要重写接口中的所有抽象方法.(主要用法)\n接口成员特点成员变量:\n\n只能是常量\n默认修饰符 public static final（建议自己写出来，比较明确，不宜出错）构造方法:\n接口没有构造方法。因为接口主要是扩展功能，而没有具体存在。成员方法:\n只能是抽象方法\n默认修饰符 public abstract（建议自己写出来，比较明确，不宜出错）\n\n所有类都默认继承自一个类：object类 object 是类层次结构的根类。每个类都使用 object 作为超类。\n接口实现类格式(命名规则)\n接口名+Impl这种格式是接口的实现类格式\n  class InterImpl implements Inter&#123;\n\n  &#125;\n  //InterImpl\n\n\n\n类与类,类与接口,接口与接口的关系类与类\n\n继承关系，只能单继承，但是可以多层继承。类与接口\n实现关系，可以单实现，也可以多实现。还可以在继承一个类的同时实现多个接口。interface Father&#123;\n\tpublic abstract void show();\n&#125;\ninterface Mother&#123;\n\tpublic abstract void show2();\n&#125;\n\nclass Son extends Object implements Father,Mother&#123;\n\tpublic void show()&#123;\n\t\tSystem.out.println(&quot;show son&quot;);\n\t&#125;\n\tpublic void show2()&#123;\n\t\tSystem.out.println(&quot;show2 son&quot;);\n\t&#125;\n&#125;\n接口与接口\n继承关系，可以单继承，也可以多继承。interface Father&#123;\n\tpublic abstract void show();\n&#125;\ninterface Mother&#123;\n\tpublic abstract void show2();\n&#125;\n\ninterface Sister extends Father,Mother&#123;\n\t&#x2F;*\n\t等于继承了\n\tpublic abstract void show();\n\tpublic abstract void show2();\n\t*&#x2F;\n&#125;\n\n抽象类和接口的区别成员区别\n\n抽象类:变量,常量;有抽象方法;抽象方法,非抽象方法.\n接口:常量;抽象方法.关系区别\n类与类:继承,单继承\n类与接口:实现,单实现,多实现\n接口与接口:继承,单继承,多继承设计理念区别\n抽象类:被继承体现的是:”is a”的关系.共性功能.抽象类中定义的是该继承体系的共性功能.\n接口:被实现体现的是:”like a”的关系.扩展功能.接口中定义的是该继承体系的扩展功能.\n\n","slug":"接口","date":"2018-12-10T02:22:34.000Z","categories_index":"Java","tags_index":"Java学习总结,面向对象","author_index":"Allen Yang"},{"id":"166ef0124d1706b7cbddeea81ab00167","title":"抽象类","content":"抽象类概括在Java中，一个没有方法体的方法应该定义为抽象方法，而类中如果有抽象方法，该类必须定义为抽象类。\n抽象类的特点1.抽象类和抽象方法必须用abstract关键字修饰\n\n格式\nabstract class 类名{}\npublic abstract void eat();\n\n2.抽象类不一定有抽象方法，但有抽象方法的类一定是抽象类\n3.抽象类不能实例化\n\n抽象类如何实例化?\n按照多态的方法，由具体的子类实例化。其实这也是多态的一种，抽象类多态。抽象类有构造方法，但是不能实例化。抽象类中构造方法的作用是用于子类访问父类数据的初始化。\n\n4.抽象类的子类\n\n如果不想重写抽象方法，该子类是一个抽象类\n重写所有的抽象方法，这个时候子类是一个具体的类\n\n5.抽象类的实例化其实是靠具体的子类实现的，是多态的方式。\n\nAnimal a = new Cat();\n\n抽象类的成员特点成员变量\n\n可以是变量\n也可以是常量构造方法\n有构造方法，但是不能实例化\n构造方法的作用是用于子类访问父类数据的初始化成员方法\n可以有抽象方法 限定子类必须完成某些动作\n也可以有非抽象方法 提高代码复用性\n\n抽象类小问题1.一个类没有抽象方法,但是也可以定义为抽象类.目的是不让创建对象.2.抽象类(abstract)不能喝哪些关键字共存\n\nprivate 冲突  (无法被重写)\nfinal   冲突  (无法被重写)\nstatic  无意义(抽象没有方法体,所以无意义)\n\n","slug":"抽象类","date":"2018-12-09T01:34:55.000Z","categories_index":"Java","tags_index":"Java学习总结,面向对象","author_index":"Allen Yang"},{"id":"0528be18df5e638068d2debce4ac533e","title":"继承","content":"概述多个类中存在相同属性和行为时，将这些内容抽取到单独一个类中，那么多个类无需再定义这些属性和行为，只要继承那个类即可。通过extends关键字可以实现类与类的继承\nclass 子类名 extends父类名&#123;&#125;\n\n单独的这个类成为父类，基类或者超类；这多个类可以称位子类或者派生类。有了继承以后，我们定义一个类的时候，可以在一个已经存在的类的基础上，还可以定义自己的新成员。\n好处：1.提高代码复用性。2.提高了代码的维护性。3.让类与类之间产生了关系，是多态的前提。（即时好处也是弊端）弊端：1.类的耦合性增强了。\n开发原则：低耦合，高内聚。\n耦合：类与类的关系。\n内聚：就是自己完成某件事的能力。\n\n2.打破了封装性。\nJava中继承的特点1.Java只支持单继承，不支持多继承。（有些语言是支持多继承，格式：extends 类1，类2，…）2.Java支持多层继承（继承体系）\nclass GrandFather&#123;\n\tpublic void show() &#123;\n\t\tSystem.out.println(&quot;爷爷&quot;);\n\t&#125;\n&#125;\nclass Father extends GrandFather&#123;\n\tpublic void show1() &#123;\n\t\tSystem.out.println(&quot;爸爸&quot;);\n\t&#125;\n&#125;\nclass Son extends Father&#123;\n\tpublic void show2() &#123;\n\t\tSystem.out.println(&quot;儿子&quot;);\n\t&#125;\n&#125;\npublic static void main(String[] args)&#123;\n\tSon s &#x3D; new Son();\n\ts.show();&#x2F;&#x2F;爷爷\n\ts.show1();&#x2F;&#x2F;爸爸\n\ts.show2();&#x2F;&#x2F;儿子\n&#125;\n继承的注意事项1.子类只能继承父类所有非私有的成员(成员方法和成员变量)2.子类不能继承父类的构造方法，但是可以通过super关键字去访问父类的构造方法。3.不要为了部分功能而去继承\nclass A&#123;\n    public void show1()&#123;&#125;\n    public void show2()&#123;&#125;\n&#125;\nclass B&#123;\n    public void show2()&#123;&#125;\n    public void show3()&#123;&#125;\n&#125;\n\n    class B extends A&#123;\n    public void show3()&#123;&#125;\n&#125;//这样做不好多出了show1\n\n何时用继承假设法:如果有两个类A,B.只有他们符合A是B的一种,或者B是A的一种,就可以考虑使用继承.eg:A:水果B:苹果苹果 extends 水果\n继承中的关系继承中成员变量的关系A:子类中的成员变量和父类中的成员变量名称不一样,直接继承.B:子类中的成员变量和父类中的成员变量名称一样,就近原则.结论:在子类方法中访问一个变量1.首先在子类局部范围找2.然后再子类成员范围找3.最后在父类成员范围找(肯定不能访问到父类局部范围)4.如果还是没有就报错(不考虑父类的父类.)\n继承中构造方法的关系A:子类中所有的构造方法默认都会访问父类中空参数的构造方法B:A为什么?因为子类会继承父类中的数据，可能会使用父类的数据。所以，子类初始化之前，一定要先完成父类数据的初始化。子类每一个构造方法的第一条语句默认都是：super()\n继承中构造方法的注意事项如果父类没有无参构造方法,那么子类的构造方法会报错.解决方法:1.在父类中加一个无参构造方法2.通过使用super关键字去显示的调用父类的带参构造方法3.子类通过this去调用本类的其他构造方法，子类中一定要有一个去访问父类的构造方法，否则父类数据就没有初始化。注意事项：this(…)或者super(…)必须出现在第一条语句上。如果没有放在第一条语句上，就可能对父类的数据进行了多次初始化，所以必须放在第一条语句上。\n继承中成员方法的关系A:子类中的方法和父类中的方法声明不一样,直接继承.B:子类中的方法和父类中的方法声明一样,就近原则.通过子类对象调用方法:1.先找子类中,看有没有这个方法,有就使用.2.再看父类中,有没有这个方法,有就使用.3.如果没有就报错.\nthis和super的区别super的用法和this很像：this代表本类对应的引用super代表父类存储空间的标识(可以理解为父类引用，可以操作父类的成员)用法：1.调用成员变量\nthis.成员变量 //调用本类的成员变量\nsuper.成员变量 //调用父类的成员变量\n\n2.调用成员方法\nthis(...) //调用子类的构造方法\nsuper(...) //调用父类的构造方法\n\n3.调用成员方法\nthis.成员方法 //调用子类的成员方法\nsuper.成员方法 //调用父类的成员方法\n\n初始化流程\n问题\n方法重写(override)方法重写：子类中出现了和父类中方法声明一模一样的方法，也被称位方法覆盖，方法复写。使用特点：如果方法名不同，有就调用对应的方法如果方法名相同，最终使用的是子类自己的应用:当子类需要父类的功能，而功能主题子类有自己特有内容时，可以重写父类中的方法，这样，即沿袭了父类的功能，有定义了子类特有的内容。\npublic class Phone&#123;\n\tpublic void call(String name)&#123;\n\t\tSystem.out.println(&quot;给&quot; + name + &quot;打电话&quot;);\n\t&#125;\n&#125;\npublic class NewPhone&#123;\n\tpublic void call(String name)&#123;\n\t\t&#x2F;&#x2F;System.out.println(&quot;给&quot; + name + &quot;打电话&quot;);\n\t\tsuper.call(name);\n\t\tSystem.out.println(&quot;看天气预报&quot;);\n\t&#125;\n&#125;\n\npublic class CallPhone&#123;\n\tpublic static void main(String[] args)&#123;\n\t\tNewPhone np &#x3D; new NewPhone();\n\t\tnp.call(&quot;胖虎&quot;);\n\t&#125;\n&#125;\n注意事项：1.父类中私有方法不能被重写 (父类私有子类根本无法继承)2.子类重写父类方法时，访问权限不能太低3.父类静态方法，子类也必须通过静态方法进行重写。(算不上重写，但是现象是重写)\n子类重写父类方法的时候，最好声明一模一样\n关键字final由于继承中方法有一个现象：方法重写。所以，父类的功能，就会被子类给覆盖掉。有时不想让子类覆盖父类的功能，只能提供给子类使用。就可以用final关键字。\nfinal：最终的意思。可以修饰类，方法，变量。\n特点：1.final可以修饰类，该类不能被继承。2.final可以修饰方法，该方法不能被重写。（覆盖，复写）3.final可以修饰变量，该变量不能被重新赋值。因为这个变量其实是常量。\n常量：A：字面常量：”hello”,10,trueB：自定义常量：final int x = 10;\nfinal修饰局部变量的问题基本类型:基本类型的值不能发生改变.引用类型:引用类型的地址值不能发生改变,但是,该对象的堆内存的值是可以改变的\nfinal修饰变量的初始化时机A:被final修饰的变量只能赋值一次.B:在构造方法完毕前.(非静态的常量)\n多态多态概述某一个事物,在不同时刻表现出来的不同状态.\n\n举例:猫可以是猫的类型.猫 m = new 猫();同时猫也是动物的一种,也可以把猫称为动物.动物 d = new 猫();水(液态,固态,气态)\n多态的前提:1.要有继承关系.2.要有方法重写.(其实没有也是可以的,但是如果没有这个就没有意义)3.要有父类引用指向子类对象. 父 f = new 子();\n多态中的成员访问特点:A:成员变量(编译看左边,运行看右边.)B:构造方法(创建子类对象的时候,访问父类的构造方法,对父类的数据进行初始化.)C:成员方法(编译看左边,运行看右边.方法存在复写,就显示子类的成员方法.)D:静态方法(编译看左边,运行看左边.{静态和类相关,算不上重写.所以访问的还是左边})\n由于成员方法存在方法重写,所以它运行看右边.\n多态的好处1.提高了代码的维护性(继承保证)2.提高了代码的扩展性(由多态保证)\n多态的弊端不能使用子类的特有功能\n多态的向下转型和向上转型向上转型：\nFu f = new Zi();\n\n向下转型：\nZi z = (Zi)f;//要求该f必须是能够转换为Zi的.\n\n多态内存图解\n\n\n\n\n\n\n\n\n多态继承中的内存图解\n\n\n\n\n\n\n\n\n\n\n多态中的对象变化内存图解\n\nClassCastException：类型转换异常一般在多态的向下转型中容易出现\n","slug":"继承","date":"2018-12-08T02:02:19.000Z","categories_index":"Java","tags_index":"Java学习总结,面向对象","author_index":"Allen Yang"},{"id":"efa8c010c59ff382983a4c1b80223f3a","title":"代码块","content":"代码块在Java中，使用{}括起来的代码被称为代码块，根据其位置和声明的不同，可以分为局部代码块，构造代码块，静态代码块，同步代码块。\n局部代码块在方法中出现；限定变量生命周期，及早释放，提高内存利用率。\npublic static void main(String[] args)&#123;\n\t//局部代码块\n\t&#123;\n\t\tint x = 10;\n\t\tSystem.out.println(x);\n\t&#125;\n\t//找不到符号，不能在代码块外使用。\n\tSystem.out.println(x);\n\t//代码块依次执行\n\t&#123;\n\t\tint x = 20;\n\t\tSystem.out.println(x);\n\t&#125;\n&#125;\n构造代码块在类中方法外出现；多个构造方法中相同的代码存放到一起，每次调用构造都执行，并且在构造方法前执行。作用：可以把多个构造方法中的共同代码放到一起。\nclass Code&#123;\n\t&#123;\n\t\tint x &#x3D; 100;\n\t\tSystem.out.println(x);\n\t&#125;\n\tpublic Code()&#123;\n\t\tSystem.out.println(&quot;code&quot;);\n\t&#125;\n\tpublic Code(int a)&#123;\n\t\tSystem.out.println(&quot;code&quot;);\n\t&#125;\n\t&#123;\n\t\tint y &#x3D; 200;\n\t\tSystem.out.println(y);\n\t&#125;\n\t&#123;\n\t\tint z &#x3D; 300;\n\t\tSystem.out.println(z);\n\t&#125;\n&#125;\npublic static void main(String[] args)&#123;\n\tCode c &#x3D; new Code();&#x2F;&#x2F;代码块执行,且构造方法最后执行。\n\tCode c1 &#x3D; new Code();&#x2F;&#x2F;代码块执行,且构造方法最后执行。\n&#125;\n静态代码块在类中方法外出现，并加上static修饰；用于给类进行初始化，在加载的时候就执行，并且只执行一次。\nclass Code&#123;\n\t&#x2F;&#x2F;静态代码块\n\tstatic &#123;\n\t\tint x &#x3D; 1000;\n\t\tSystem.out.println(x);\n\t&#125;\n\t&#x2F;&#x2F;静态代码块\n\tstatic &#123;\n\t\tint b &#x3D; 2000;\n\t\tSystem.out.println(b);\n\t&#125;\n\t&#x2F;&#x2F;构造方法\n\tpublic Code()&#123;\n\t\tSystem.out.println(&quot;code&quot;);\n\t&#125;\n\t&#x2F;&#x2F;构造方法\n\tpublic Code(int a)&#123;\n\t\tSystem.out.println(&quot;code&quot;);\n\t&#125;\n\t&#x2F;&#x2F;构造代码块\n\t&#123;\n\t\tint y &#x3D; 200;\n\t\tSystem.out.println(y);\n\t&#125;\n\t&#x2F;&#x2F;构造代码块\n\t&#123;\n\t\tint z &#x3D; 300;\n\t\tSystem.out.println(z);\n\t&#125;\n&#125;\npublic static void main(String[] args)&#123;\n\tCode c &#x3D; new Code();&#x2F;&#x2F;先执行静态代码块，后执行构造代码块代码块,构造方法最后执行。\n\tCode c1 &#x3D; new Code();&#x2F;&#x2F;静态代码块只执行一次，所以这次不执行。代码块执行,构造方法最后执行。\n&#125;\n同步代码块","slug":"代码块","date":"2018-12-07T02:42:11.000Z","categories_index":"Java","tags_index":"Java学习总结,面向对象","author_index":"Allen Yang"},{"id":"028ef52bbaecf50bd1bcb213347b2846","title":"帮助文档的制作以及使用","content":"制作工具类的说明书（文档注释）文档注释格式：\n/**\n*\n*\n*\n*\n*\n*\n*/\n\n字段\n@author  (作者)@version (版本)@param   (参数)@return  (返回值)\njavadoc格式：\njavadoc -d 目录 -author -version XXXX.java\n\n目录：可以写一个文件夹的路径注释文档中不需要写类型\n制作帮助文档出错：找不到可以文档化的公共或受保护的类：告诉我们类的权限不够。 （一般给类加上public就可以了）\n如何使用帮助文档(JDK API 1.6.0 中文版为例)以Scanner为例：1.打开帮助文档2.点击显示，找到索引，看到输入框3.在输入框里面输入Scanner，然后回车4.看包&emsp;java.lang包下的类不需要导入，其他的全部需要导入。&emsp;Scanner在java.unil下需要导入：&emsp;java.util.Scanner5.看类的注释和说明还有举例，以及类的版本。6.看类的结构&emsp;成员方法—字段摘要&emsp;构造方法—构造方法摘要&emsp;成员方法—方法摘要7.学习构造方法&emsp;A:有构造方法    就创建对象&emsp;B:没有构造方法    成员可能都是静态的8.看成员方法&emsp;A:左边&emsp;&emsp;是否静态：如果静态，可以通过类名调用。&emsp;&emsp;返回值类型：返回什么，就用什么接受。&emsp;B:右边&emsp;&emsp;看方法名：方法名称不能写错。&emsp;&emsp;参数列表：需要什么就给什么，需要几个就给几个。\n","slug":"帮助文档的制作以及使用","date":"2018-12-06T15:50:11.000Z","categories_index":"Java","tags_index":"Java学习总结,面向对象","author_index":"Allen Yang"},{"id":"43b177c0ef2e494c11cddc986521f4d9","title":"面向对象","content":"面向对象面向对象思想面向对象是基于面向过程面向过程:强调的是每一个功能的步骤.面向对象:强调的是对象,然后由对象去调用功能(强调结果).\n面向对象特点A:是一种更符合我们思想习惯的思想.B:可以将复杂的事情简单化.C:将我们以执行者变成指挥者.eg:自己去打水变成让别人去打水.\n举例买电脑面向过程:了解电脑 -&gt; 了解自己的需求 -&gt; 找对应的参数信息 -&gt; 去买电脑 -&gt; 讨价还价 -&gt; 买回电脑面向对象:要买电脑 -&gt; 找人去给我买 -&gt; 买回来了\n举例把大象装进冰箱面向过程:动作步骤:1.打开冰箱门 2.装进大象 3.关闭冰箱门\nclass Demo&#123;\n\tpublic static void main(String[] args)&#123;\n\t\topen();\n\t\tin();\n\t\tclose();\n&#125;\n\tpublic static void open()&#123;\n\t\tSystem.out.println(&quot;打开冰箱门&quot;);\n&#125;\n\tpublic static void in()&#123;\n\t\tSystem.out.println(&quot;装进大象&quot;);\n&#125;\n\tpublic static void close()&#123;\n\t\tSystem.out.println(&quot;关闭冰箱门&quot;);\n&#125;\n&#125;\n\n面向对象:我们怎么才能更符合面向对象思想呢?A:有哪些类?B:每个类有哪些东西?C:类与类直接的关系是什么?\n把大象装进冰箱的分析?(如何分析有哪些类呢?UML.名词提取法.)A:有哪些类呢? 大象,冰箱,Demo.B:每个类有哪些东西呢? 大象:进去 , 冰箱:开门,关门 , Demo:main方法.C:类与类直接的关系是什么呢? Demo中使用大象和冰箱类的功能.\nclass Daxiang&#123;\n\tpublic static void in()&#123;\n\t\tSystem.out.println(&quot;装进大象&quot;);\n&#125;\n&#125;\n\nclass Bingxiang&#123;\n\tpublic static void open()&#123;\n\t\tSystem.out.println(&quot;打开冰箱门&quot;);\n&#125;\n\tpublic static void close()&#123;\n\t\tSystem.out.println(&quot;关闭冰箱门&quot;);\n&#125;\n&#125;\n\nclass Demo&#123;\n\tpublic static void main(String[] args)&#123;\n\t\tDaxiang dx &#x3D; new Daxiang();\n\t\tBingxiang bx &#x3D; new Bingxiang();\n\t\tbx.open();\n\t\tdx.in();\n\t\tbx.close();\n&#125;\n&#125;\n\n面向对象开发、设计及特征开发:不断的创建对象,使用对象,指挥对象做事情.设计:管理和维护对象之间的关系.特征:封装(encapsulation),继承(inheritance),多态(polymorphism).\n类的定义和概述事物:\n属性:事物的信息描述\n行为:事物的功能\n\n类:\n成员变量:事物的属性\n成员方法:事物的行为\n\n类:是一组相关的属性和行为的集合,是一个抽象的概念.对象:是该类事物的具体表现形式.具体存在的个体.定义一个类,其实就是定义该类的成员变量和成员方法.\n创建对象创建对象格式:类名 对象名 = new 类名();\n\n使用成员变量:\n对象名.变量名;\n\n使用成员方法:\n对象名.方法名(...); \n\n成员变量和局部变量的区别在类中的位置不同成员变量:在类中方法外.局部变量:在方法定义中或者方法声明上.\n在内存中的位置不同成员变量:在堆内存中.局部变量:在栈内存中.\n生命周期不同成员变量:随着对象的创建而存在随着对象的消失而消失.局部变量:随着方法的调用而存在,随着方法调用完毕而消失.\n初始化值不同成员变量:有默认初始化值.局部变量:没有默认初始化值,必须定义赋值才能使用.\n注:局部变量名称可以和成员变量名称一样,在方法中使用的时候,采用就近原则.\n创建对象内存图创建一个对象内存图创建两个对象内存图创建三个对象内存图\n形式参数基本类型:形式参数的改变不影响实际参数.引用类型:形式参数的改变直接影响实际参数.\n类是一个引用类型如果看到一个方法的形式参数是一个类类型(引用类型),这里需要的是该类的对象对象.\n&#x2F;&#x2F;形式参数是基本类型例子\nclass Demo&#123;\n\tpublic int sum(int a,int b)&#123;\n\t\treturn a + b;\n\t&#125;\n&#125;\n&#x2F;&#x2F;形式参数是引用类型\nclass Student&#123;\n\tpublic void show()&#123;\n\t\tSystem.out.println(&quot;我爱学习&quot;);\n\t&#125;\n&#125;\n\nclass StudentDemo&#123;\n\tpublic void method(Student s)&#123;&#x2F;&#x2F;调用的时候,把main方法中的s的地址值传递到了这里 Stduent s &#x3D; new Student();\n\t\ts.show();\n\t&#125;\n&#125;\n\nclass ArgsTest&#123;\n\tpublic static void main(String[] args)&#123;\n\t\t&#x2F;&#x2F;形式参数是基本类型的调用\n\t\tDemo d &#x3D; new Demo();\n\t\tint result &#x3D; d.sum(10,20);\n\t\tSystem.out.println(&quot;result:&quot; + result);\n\n\t\t&#x2F;&#x2F;形式参数是引用类型的调用\n\t\t&#x2F;&#x2F;需求:要调用StudentDemo类中的method()方法\n\t\tStudentDemo sd &#x3D; new StudentDemo();\n\t\t&#x2F;&#x2F;创建学生对象\n\t\tStduent s &#x3D; new Student();\n\t\tsd.method(s);&#x2F;&#x2F;把s的地址给到了这里\n\t&#125;\n&#125;\n\n匿名对象匿名对象:就是没有名字的对象.匿名对象的应用场景:\nA:调用方法,仅仅只调用一次的时候.\n注意:多次的时候,不适合.\n好处:匿名对象调用完毕就是垃圾,可以被垃圾回收器回收.\nB:匿名对象可以作为实际参数传递.\n\nclass Student &#123;\n\tpublic void show()&#123;\n\t\tSystem.out.println(&quot;我爱学习&quot;).\n\t&#125;\n&#125;\n\nclass StudentDemo&#123;\n\tpublic void method(Student s)&#123;\n\t\ts.show();\n\t&#125;\n&#125;\n\nclass NoNameDemo&#123;\n\tpublic static void main(String[] args)&#123;\n\t\t&#x2F;&#x2F;带名字的调用\n\t\tStudent s &#x3D; new Student();\n\t\ts.show();\n\n\t\t&#x2F;&#x2F;匿名对象\n\t\t&#x2F;&#x2F;new Student();\n\t\t&#x2F;&#x2F;匿名对象调用方法\n\t\tnew Student().show();&#x2F;&#x2F;这里其实是创建了一个新的对象\n\n\t\t&#x2F;&#x2F;匿名对象作为实际参数传递\n\t\tStudentDemo sd &#x3D; new StudentDemo();\n\t\t&#x2F;&#x2F;带名字的调用\n\t\tStudent ss &#x3D; new Student();\n\t\tsd.method(ss);&#x2F;&#x2F;这里的s是一个实际参数.\n\t\t&#x2F;&#x2F;匿名对象\n\t\tsd.method(new Student());\n\t\t&#x2F;&#x2F;全部匿名对象\n\t\tnew StudentDemo().method(new Student());\n\t&#125;\n&#125;\n\n封装封装:\n隐藏对象的属性和实现细节,仅对外提供公共访问方式.\n\n好处:\n隐藏实现细节,提供公共的访问方式.\n提高了代码的复用性\n提高了安全性\n\n封装原则:\n将不需要对外提供的内容都隐藏起来.\n把属性隐藏,提供公共方法对其访问.\n\nprivate关键字:\n是一个权限修饰符.\n可以修饰成员变量和成员方法.\n被private修饰的成员只能在本类中访问.\n\n常见应用:\n把成员变量用private修饰,提供对应的getXxx()/setXxx()方法.\n\nthis:\n是当前类的对象引用.简单记,它就代表当前类的一个对象.\n注意:对象调用哪个方法,this就代表谁\n\nthis的场景:\n解决局部变量隐藏成员变量.\n\n内存图解:\n构造方法构造方法:给对象的数据进行初始化格式:\nA:方法名与类名相同\nB:没有返回值类型,连void都没有\nC:没有具体的返回值\n\n注意事项:\nA:如果没有给出构造方法,系统将会自动提供一个无参构造方法.\nB:如果给出了任意构造方法,系统将不再提供默认的无参构造方法,如果还想使用无参构造方法,就必须自己给出.建议永远自己给出无参构造方法.\n\n给成员变量赋值的两种方法:A:setXxx()B:构造方法\nclass Student&#123;\n\tpublic Student()&#123;\n\t\tSystem.out.println(&quot;这是构造方法&quot;);\n\t&#125;\n&#125;\n\nclass ConstructDemo&#123;\n\tpublic static void main(String[] args)&#123;\n\t\t&#x2F;&#x2F;创建对象\n\t\tStudent s &#x3D; new Student();\n\t\tSystem.out.println(s);&#x2F;&#x2F;会输出地址值\n\t&#125;\n&#125;\n\n类的组成类的组成:\n成员变量\n\n成员方法\n1.无参构造方法\n2.带参构造方法\n\n构造方法\ngetXxx()\nsetXxx()\n\n给成员变量赋值的方式\n无参构造方法+setXxx()\n带参构造方法\n\n变量什么时候定义为成员变量?:\n如果这个变量是用来描述这个类的信息的,那么该变量就应该定义为成员变量.\n\n变量定义在哪里好?:\n变量的范围是越小越好,因为能及时的被回收.\n\n根据返回值分类:\nvoid类型\n非void类型\n\n根据形式参数分类:\n空参方法\n非空参方法\n\nclass Student &#123;\n\tpublic String getString()&#123;\n\t\treturn &quot;helloworld&quot;;\n\t&#125;\n\tpublic void show()&#123;\n\t\tSystem.out.println(&quot;show&quot;);\n\t&#125;\n\tpublic void method(String name)&#123;\n\t\tSystem.out.println(name);\n\t&#125;\n\tpublic String function(String s1,String s2)&#123;\n\t\tretrun s1 + s2;\n\t&#125;\n&#125;\n\nclass StudentDemo&#123;\n\tpublic static void main(String[] args)&#123;\n\t\t&#x2F;&#x2F;创建对象\n\t\tStudent s &#x3D; new Student();\n\t\t&#x2F;&#x2F;调用无参无返回值方法\n\t\ts.show();\n\t\t&#x2F;&#x2F;调用无参有返回值方法\n\t\tString result &#x3D; s.getString();\n\t\tSystem.out.println(result);\n\t\t&#x2F;&#x2F;调用带参无返回值的方法\n\t\ts.method(&quot;Fatih&quot;);\n\t\t&#x2F;&#x2F;调用带参带返回值的方法\n\t\tString result2 &#x3D; s.function(&quot;hello&quot;,&quot;world&quot;);\n\t\tSystem.out.println(result2);\n\t&#125;\n&#125;\n\n创建对象内存图\nstatic关键字static关键字特点:A:随着类的加载而加载. eg:main方法\nB:优先于对象存在.\nC:被类的所有对象共享:\n如果某个成员变量是被所有对象共享的,那么它就应该定义为静态的.\neg:饮水机(用静态修饰),水杯(不能用静态修饰)\nD:可以通过类名调用(本身也可以通过对象名调用)\n推荐使用类名调用\n\n静态修饰的内容一般称其为:与类相关的,类成员.\nstatic的内存图解:\nstatic关键字注意事项A:在静态方法中是没有this关键字的\n理解:静态是随着类的加载而加载,this是随着对象的创建而存在的.静态比对象先存在.\n\nB:静态方法只能访问静态的成员变量和静态的成员方法.\n\n静态方法:\n成员变量:只能访问静态变量.\n成员方法:只能访问静态成员方法.\n\n非静态方法:\n成员变量:可以是静态的,也可以是非静态的.\n成员方法:可以是静态的成员方法,也可以是非静态的成员方法.\n\n简单记:静态只能访问静态\n\n静态变量和成员变量所属不同\n静态变量属于类,所以也成为类变量.\n成员变量属于对象,所以也成为实例变量(对象变量).\n\n内存中位置不同\n静态变量存储于方法区的静态区.\n成员变量存储于堆内存.\n\n内存出现时间不同\n静态变量随着类的加载而加载,随着类的消失而消失.\n成员变量随着对象的创建而存在,随着对象的消失而消失.\n\n调用不同\n静态变量可以通过类名调用,也可以通过对象调用.\n成员变量只能通过对象名调用.\n\nmain方法格式详解public static void main (String[] args)&#123;...&#125;\n\npublic:公共的,访问权限是最大的.由于main方法是被jvm调用,所以权限要够大.\n\nstatic:静态的,不需要创建对象,通过类名就可以.方便jvm的调用.\n\nvoid:方法的返回值是返回给调用者,而main方法是被jvm调用.而返回给jvm没有意义.\n\nmain:是一个常见的方法入口.几乎所有语言都是以main作为入口.\n\nString[] args:这是一个字符串数组.(早期是为了接收键盘录入的数据的)\n格式是:java 类名 xxx xxx xxx\n\nclass MainDemo&#123;\n\tpublic static void main(String[] args)&#123;\n\t\tSystem.out.println(args);&#x2F;&#x2F;[Ljava.lang.String;@175078b输出一个地址值\n\t\tSystem.out.println(args.length);&#x2F;&#x2F;0\n\t\tSystem.out.println(args[0]);&#x2F;&#x2F;ArrayIndexOutOfBoundsException(越界)\n\n\t\tcmd键入 java MainDemo hello world java\n\t\tSystem.out.println(args);&#x2F;&#x2F;[Ljava.lang.String;@175078b输出一个地址值\n\t\tSystem.out.println(args.length);&#x2F;&#x2F;3\n\t\tSystem.out.println(args[0]);&#x2F;&#x2F;hello\n\t\tSystem.out.println(args[1]);&#x2F;&#x2F;world\n\t\tSystem.out.println(args[2]);&#x2F;&#x2F;java\n\t&#125;\n&#125;\n\n如何实现只能通过类名调用方法类中所有方法都使用静态方法，将构造方法私有，外界就不能再创建对象了，只能通过类名调用。\n","slug":"面向对象","date":"2018-12-06T15:03:21.000Z","categories_index":"Java","tags_index":"Java学习总结,面向对象","author_index":"Allen Yang"},{"id":"e16187d7a3c490f96b788338bdd79d24","title":"数组","content":"一维数组定义格式:A:数据类型[] 数组名;\nB:数据类型 数组名[];\neg: A:int[] a;\n    B:int a[];\n\n推荐使用第一种.\n初始化int[] arr &#x3D; new int[3];\n\n&#x2F;*左边:\n\t int:说明数组中的元素的数据类型是int类型.\n\t []:说明这是一个数组.\n\t arr:是数组的名称.\n  右边:\n\t new:为数组分配内存空间.\n\t int:说明数组中的元素的数据类型是int类型.\n\t []:说明这是一个数组.\n\t 3:数组长度,其实也就是数组中元素的个数.\n*&#x2F;\n\n获取数组元素数组名[索引]索引就是每个元素的编号,从0开始,最大索引是数组的长度-1.\n数组内存分配int [] arr &#x3D; new int [3];\nSystem.out.println(arr); &#x2F;&#x2F;地址值\nSystem.out.println(arr[0]); &#x2F;&#x2F;0\nSystem.out.println(arr[1]); &#x2F;&#x2F;0\nSystem.out.println(arr[2]); &#x2F;&#x2F;0\n\n&#x2F;&#x2F;定义第一个数组\nint[] arr &#x3D; new int[3];\narr[0] &#x3D; 88; &#x2F;&#x2F;88\narr[1] &#x3D; 33; &#x2F;&#x2F;33\narr[2] &#x3D; 66; &#x2F;&#x2F;66\n&#x2F;&#x2F;定义第二个数组\nint[] arr2 &#x3D; new int[3];\narr[0] &#x3D; 22; &#x2F;&#x2F;22\narr[1] &#x3D; 44; &#x2F;&#x2F;44\narr[2] &#x3D; 55; &#x2F;&#x2F;55\n&#x2F;&#x2F;定义第三个数组\nint[] arr3 &#x3D; arr;\narr3[0] &#x3D; 100;&#x2F;&#x2F;100\narr3[1] &#x3D; 200;&#x2F;&#x2F;200\n&#x2F;*改变arr3的值也改变了arr的值,arr的地址值赋给了arr3\n  栈内存的两个引用指向同一个堆内存空间.\n  无论是它们谁的操作,都是针对同一个地方.\n*&#x2F;\n\n\n二维数组定义格式(标准):数据类型[ ][ ] 数组名 = new 数据类型[m][n];\nm表示这个二维数组有多少个一维数组.\nn表示每一个一维数组的元素个数.\n\n其他格式:a:数据类型 数组名[ ][ ] = new 数据类型[m][n];\nb:数据类型[ ] 数组名[ ] = new 数据类型[m][n];\nc:数据类型[ ][ ] 数组名 = new 数据类型[m][n];(标准)\nd:数据类型[ ][ ] 数组名 = new 数据类型[m][ ];(一维数组元素个数可以动态给出)\ne:数据类型[ ][ ] 数组名 = new 数据类型[ ][ ]&#123;&#123;元素...&#125;,&#123;元素...&#125;,&#123;元素...&#125;&#125;;(直接赋值)\nf:数据类型[ ][ ] 数组名 = &#123;&#123;元素...&#125;,&#123;元素...&#125;,&#123;元素...&#125;&#125;;(e的简化版)\n\n\n传递值问题基本类型传递值   ---&gt;   值(不改变方法中调用的值)\n引用类型传递值   ---&gt;   地址值(改变方法中调用的值)\n\n","slug":"数组","date":"2018-12-06T15:03:13.000Z","categories_index":"Java","tags_index":"Java学习总结","author_index":"Allen Yang"},{"id":"966fe18182df54e4070010e55431368b","title":"内存","content":"内存介绍栈内存:存放的是局部变量.(局部变量:在方法定义中或者方法声明上的变量都称为局部变量)\n堆内存:存放的是所有new出来的东西.\n\n堆内存的特点A:每一个new出来的东西都有地址值.\nB:每个变量都有默认值.\n  byte、short、int、long 默认值都是 0\n  float、double 默认值都是 0.0\n  char 默认值 &#39;\\u0000&#39;\n  boolean 默认值 false\n  引用类型 默认值 null\nC:使用完毕就变成了垃圾,但是并没有立即回收.会在垃圾回收器空闲的时候回收.\n\n栈内存的特点栈内存的数据用完就释放掉.\n\n","slug":"内存","date":"2018-12-06T15:02:32.000Z","categories_index":"Java","tags_index":"Java学习总结","author_index":"Allen Yang"},{"id":"ccc6d908234d53adbdf0dbdbe397c4b9","title":"转义字符","content":"转义字符&#39;\\t&#39; tab键的位置\n&#39;\\r&#39; 回车\n&#39;\\n&#39; 换行\n\n","slug":"转义字符","date":"2018-12-06T15:02:13.000Z","categories_index":"Java","tags_index":"Java学习总结","author_index":"Allen Yang"},{"id":"acac08cfdbc1a7f3ce719da524fb29ff","title":"选择结构","content":"选择结构(switch)switch语句结构 : \nswitch(表达式)&#123;\n\tcase值1:\n\t\t语句体1;\n\t\tbreak;\n\tcase值2:\n\t\t语句体2;\n\t\tbreak;\n\t...\n\tdefault:\n\t\t语句体n+1;\n\t\tbreak;&#125;\n\n格式解释 :\nswitch:表示这是switch结构.\n表达式:这个地方的取值是有限定的.\neg:byte、short、int、char,\n   JDK5以后可以是枚举,\n   JDK7以后可以是String.\ncase:后面跟的是要和**表达式**进行比较的值.\n语句体:要执行的代码.\nbreak:表示中断,结束的意思,可以控制switch的中断.\ndefault:当所有值都和表达式不匹配的时候,就执行default控制的语句,相当于if语句中的else.\n\nswitch语句的注意事项 :\nA:case后面只能是常量,不能是变量.而且,多个case后面的值不能相同.\nB:default可以省略,但不建议,因为它的作用是对不正确的情况给出提示.\n  特殊情况省略:case就可以把值固定 eg:选择题(A、B、C、D选项)\nC:break可以省略,但是结果可能不是想要的.\nD:default可以在任意位置,但建议在最后.\nE:switch语句的结束条件:\n  1.遇到break就结束.\n  2.执行到末尾就结束.\n\n","slug":"选择结构","date":"2018-12-06T14:40:07.000Z","categories_index":"Java","tags_index":"Java学习总结","author_index":"Allen Yang"},{"id":"88ea152c24a2e3533911145f0433ed7c","title":"运算符","content":"逻辑运算符\n\n\n运算符\n含义\n用法\n结合方向\n\n\n\n&amp;&amp;、&amp;\n逻辑与\nop1&amp;&amp;op2\n从左到右\n\n\n&#124;&#124;\n逻辑或\nop1&#124;&#124;op2\n从左到右\n\n\n!\n逻辑非\n!op\n从右到左\n\n\n\n位运算符\n\n\n运算符\n运算\n举例\n\n\n\n&lt;&lt;\n左移\n3 &lt;&lt; 2 = 12 -&gt; 3 * 2 * 2 = 12\n\n\n&gt;&gt;\n右移\n3 &gt;&gt; 1 = 1 -&gt; 3 / 2 = 1\n\n\n&gt;&gt;&gt;\n无符号左移\n3&gt;&gt;&gt;1 = 1 -&gt; 3 / 2 = 1\n\n\n&amp;\n与运算\n6 &amp; 3 = 2\n\n\n&#124;\n或运算\n6 &#124; 3 = 7\n\n\n^\n异或运算\n6 ^ 3 = 5\n\n\n~\n反码\n~6 = 7\n\n\n要做位运算,首先要把数据转换为二进制. 注 : 二进制补码运算\n&lt;&lt;位运算符&lt;&lt; : 左移(左边最高位丢弃,右边补齐0)\neg : 3 &lt;&lt; 2 = 3 * 2 * 2 = 12\n\n\n\n计算出3的二进制补码:\n\n\n\n\n左移2位\n00000000 00000000 00000000 00000011\n\n\n最高位(00)舍弃\n00000000 00000000 00000000 00001100\n\n\n结论 : 把&lt;&lt;左边的数据*(乘以) 2的移动次幂\n\n\n\n&gt;&gt;位运算符&gt;&gt; : 右移 最高位是0,左边补齐0;最高位是1,左边补齐1\neg : 24 &gt;&gt; 2 = 24 / 2 ^ 2 = 6\n\n\n\n计算出24的二进制补码:\n\n\n\n\n右移2位\n00000000 00000000 00000000 00011000\n\n\n最高位补齐00\n00000000 00000000 00000000 00000110\n\n\neg : -24 &gt;&gt; 2 = -24 / 2 ^ 2 = -6\n\n\n\n计算出-24的二进制补码:\n\n\n\n\n右移2位\n11111111 11111111 11111111 11101000\n\n\n最高位补齐11\n11111111 11111111 11111111 11111010\n\n\n结论 : 把&gt;&gt;左边的数据(除以) 2的移动次幂\n\n\n\n&gt;&gt;&gt;无符号右移&gt;&gt;&gt; : 无论最高位是0还是1,左边补齐0\neg : 24 &gt;&gt;&gt; 2 = 6\n\n\n\n计算出24的二进制补码:\n\n\n\n\n右移2位\n00000000 00000000 00000000 00011000\n\n\n最高位补齐00\n00000000 00000000 00000000 00000110\n\n\neg : -24 &gt;&gt;&gt; 2 = 1073741818\n\n\n\n计算出-24的二进制补码:\n\n\n\n\n右移2位\n11111111 11111111 11111111 11101000\n\n\n最高位补齐00\n00111111 11111111 11111111 11111010\n\n\n&amp;位运算(有0则0)eg : 3 &amp; 4 = 0\n\n\n\n数值\n转换为二进制\n\n\n\n3\n00000000 00000000 00000000 00000011\n\n\n4\n00000000 00000000 00000000 00000100\n\n\n&amp;位运算后结果为0\n00000000 00000000 00000000 00000000\n\n\n|位运算(有1则1)eg : 3 &#124; 4 = 7\n\n\n\n数值\n转换为二进制\n\n\n\n3\n00000000 00000000 00000000 00000011\n\n\n4\n00000000 00000000 00000000 00000100\n\n\n&#124;位运算后结果为7\n00000000 00000000 00000000 00000111\n\n\n^位异或运算(相同则0,不同则1)eg : 3 ^ 4 = 7\n\n\n\n数值\n转换为二进制\n\n\n\n3\n00000000 00000000 00000000 00000011\n\n\n4\n00000000 00000000 00000000 00000100\n\n\n^位运算后结果为7\n00000000 00000000 00000000 00000111\n\n\n^异或位运算符特点:a = 10 , b = 20(a ^ b ^ b) = 10(a ^ b ^ a) = 20一个数据对另一个数据位异或两次,该数本身不变\n~按位取反运算符(0变1,1变0)eg : ~3 = -4\n\n\n\n数值\n转换为二进制\n\n\n\n3\n00000000 00000000 00000000 00000011\n\n\n~位运算后结果为**-4**\n11111111 11111111 11111111 11111000(补码)\n\n\n补码\n11111111 11111111 11111111 11111000\n\n\n反码\n11111111 11111111 11111111 11111011\n\n\n原码**(-4)**\n10000000 00000000 00000000 00000100\n\n\n\n重点 : 三目运算符例 :单目运算符 : -3双目运算符 : 3 + 4三目运算符(条件运算符) : \n格式 : 比较表达式 ? 表达式1 : 表达式2\n\n比较表达式 : 结果是一个Boolean类型根据比较表达式的计算返回一个true或者false,如果是true,就将表达式1作为结果.如果是false,就把表达式2作为结果.\n三目运算符例题 :     比较三个整数的最大值 :\nint a &#x3D; 10;\nint b &#x3D; 30;\nint c &#x3D; 20;\n&#x2F;&#x2F;分两步\nint temp &#x3D; (a &gt; b) ? a : b;\nint max &#x3D; (temp &gt; c) ? temp : c;\n&#x2F;&#x2F;只一步\nint max1 &#x3D; (a &gt; b) ? ( (a &gt; c) ? a : c ) : ( (b &gt; c) ? b : c );","slug":"运算符","date":"2018-12-05T17:47:10.000Z","categories_index":"Java","tags_index":"Java学习总结","author_index":"Allen Yang"},{"id":"4f8fbf9c37c8afa969e05d92a1534095","title":"ASCII码表","content":"ASCII码表ASCII（American Standard Code for Information Interchange，美国信息交换标准代码）是基于拉丁字母的一套电脑编码系统，主要用于显示现代英语和其他西欧语言。它是现今最通用的单字节编码系统，并等同于国际标准ISO/IEC 646。\n\n需要记住的三个位置‘a’ 97‘A’ 65‘0’ 48\n","slug":"ASCII码表","date":"2018-12-05T17:39:56.000Z","categories_index":"Java","tags_index":"Java学习总结","author_index":"Allen Yang"},{"id":"a760ef6d11a2d6078a812f5bc31cf898","title":"数据类型","content":"数据类型数据类型分类A : 基本数据类型B : 引用数据类型\n\n基本数据类型(4类8种)整数类型\n\n\n整数类型\n占用字节数(8位等于1字节)\n表述范围\n\n\n\nbyte\n8位\n-128 ~ 127\n\n\nshort\n16位\n-2^15 ~ 2^15 - 1\n\n\nint\n32位\n-2^31 ~ 2^31 - 1\n\n\nlong\n64位\n-2^63 ~ 2^63 - 1\n\n\n浮点类型\n\n\n浮点类型\n占用字节数(8位等于1字节)\n表述范围\n\n\n\nfloat\n32位\n-3.40E+48 ~ +3.40E+38\n\n\ndouble\n64位\n-1.79E+308 ~ +1.79E+308\n\n\n字符类型\n\n\n字符类型\n占用字节数(8位等于1字节)\n表述范围\n\n\n\nchar\n16位\n\n\n\n布尔类型\n\n\n布尔类型\n占用字节数(8位等于1字节)\n表述范围\n\n\n\nboolean\n8位\n\n\n\n\n数据转换默认转换(从小到大的转换)A : byte,short,char(一定会转换) - int - long - float - doubleB : byte,short,char 相互之间不转换,他们参与运算首先转换为int类型.\n强制转换目标类型 变量名 = (目标类型)(被转换的数据)\n","slug":"数据类型","date":"2018-12-05T16:27:24.000Z","categories_index":"Java","tags_index":"Java学习总结","author_index":"Allen Yang"},{"id":"a6e05bc12d9ba8fdabdade796d228b64","title":"二进制、原码、反码、补码问题","content":"字节大小1 byte = 8 bit1 k = 1024 byte一个字节是八位eg : 00100100(这是一个字节)\n\n进制组成与换算二进制二进制(0b开头,由0,1组成)eg : (10110110) = 2^7*1 + 2^6*0 + 2^5*1 + 2^4*1 + 2^3*0 + 2^2*1 + 2^1*1 + 2^0*0 = 182(十进制结果)\n十进制十进制(由0…..9组成)eg : (182)\n八进制八进制(0开头,由0…7组成)从右开始,每三位一个组合,最左边不够补0,然后分别算出十进制的值进行组合得到八进制的值.eg : (0266) 010|110|110 = 2^2*0 + 2^1*1 + 2^0*0 | 2^2*1 + 2^1*1 + 2^0*0 | 2^2*1 + 2^1*1 + 2^0*0 = 266(八进制结果) = 2*8^2 + 6*8^1 + 6*8^0 = 182(十进制结果)\n十六进制十六进制(0x开头,由0….9,a…f组成)同理与八进制,每四位一个组合.eg : (0xB6) 1011|0110 = 2^3*1 + 2^2*0 + 2^1*1 + 2^0*1 | 2^3*0 + 2^2*1 + 2^1*1 + 2^0*0 = B6(十六进制结果) = 11*16^1 + 6*16^0 = 182(十进制结果)\n\n十进制转各种进制示意图十进制转其他进制:口诀:除基取余,直到商为0,余数反转.\n十进制转十进制\n![](https://github.com/n0thingJy/n0thingjy.github.io/blob/master/images/%E8%BF%9B%E5%88%B6%E8%BD%AC%E6%8D%A2/%E5%8D%81%E8%BF%9B%E5%88%B6%E8%BD%AC%E6%8D%A2%E4%BA%8C%E8%BF%9B%E5%88%B6.png?raw=true)\n十进制转二进制\n**十进制转八进制,十进制转十六进制同理**\n\n\n原码,反码,补码原码原码 : 正数的原码最高位是0.负数的最高位是1,其他的是数值位.\n\n\n\n值\n符号位\n数值位\n\n\n\n+7\n0\n0000111\n\n\n-7\n1\n0000111\n\n\n反码反码 : 正数的反码和原码相同.负数的反码与原码符号位相同,数值位取反(就是1变0,0变1).\n\n\n\n值\n符号位\n数值位\n\n\n\n+7\n0\n0000111\n\n\n-7\n1\n1111000\n\n\n补码补码 : 正数的补码与原码相同.负数的补码是在反码的基础上加1.\n\n\n\n值\n符号位\n数值位\n\n\n\n+7\n0\n0000111\n\n\n-7\n1\n1111001\n\n\n","slug":"二进制","date":"2018-12-04T16:30:14.000Z","categories_index":"Java","tags_index":"Java学习总结","author_index":"Allen Yang"},{"id":"2d4d48a350a521898b927365c75c84ac","title":"Java初学小问题","content":"CMD编译格式javac + 文件名+ 扩展名 eg : javac HelloWorld.java (编译)java + 类名(不加扩展名) eg : java HelloWorld (执行)\n\nJava标识符及命名规则(见名知意)标识符组成 数字、字母、$、_ 注意 : Java关键字不可以作为标识符，(go to,const)为旧版本保留字段亦不可作为标识符使用。\n包的命名 文件夹 单极 : xxx        多级 : xxx.xxx.xxx (全部字母小写)\n类或接口 一个单词 : 单词的首字母必须大写 eg : Student,Dog 多个单词 : 每个单词的首字母必须大写 eg : HelloWorld,StudentName\n方法或变量 一个单词 : 单词的首字母小写 eg : age,student 多个单词 : 首字母小写,从第二个字母开始首字母大写 eg : studentAge,studentAllNames\n常量 一个单词 : 全部大写 eg : PI 多个单词 : 每个字母都大写,用_隔开 eg : STUDENT_MAX_AGE\n\n","slug":"Java初学小问题","date":"2018-12-04T14:00:14.000Z","categories_index":"Java","tags_index":"Java学习总结","author_index":"Allen Yang"}]