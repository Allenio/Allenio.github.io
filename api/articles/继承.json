{"title":"继承","uid":"0528be18df5e638068d2debce4ac533e","slug":"继承","date":"2018-12-08T02:02:19.000Z","updated":"2021-06-28T13:08:29.367Z","comments":true,"path":"api/articles/继承.json","keywords":null,"cover":[],"content":"<h2 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h2><p>多个类中存在相同属性和行为时，将这些内容抽取到单独一个类中，那么多个类无需再定义这些属性和行为，只要继承那个类即可。<br>通过extends关键字可以实现类与类的继承</p>\n<pre><code>class 子类名 extends父类名&#123;&#125;\n</code></pre>\n<p>单独的这个类成为父类，基类或者超类；这多个类可以称位子类或者派生类。<br>有了继承以后，我们定义一个类的时候，可以在一个已经存在的类的基础上，还可以定义自己的新成员。</p>\n<p>好处：<br>1.提高代码复用性。<br>2.提高了代码的维护性。<br>3.让类与类之间产生了关系，是多态的前提。（即时好处也是弊端）<br>弊端：<br>1.类的耦合性增强了。</p>\n<pre><code>开发原则：低耦合，高内聚。\n耦合：类与类的关系。\n内聚：就是自己完成某件事的能力。\n</code></pre>\n<p>2.打破了封装性。</p>\n<h2 id=\"Java中继承的特点\"><a href=\"#Java中继承的特点\" class=\"headerlink\" title=\"Java中继承的特点\"></a>Java中继承的特点</h2><p>1.Java只支持单继承，不支持多继承。（有些语言是支持多继承，格式：extends 类1，类2，…）<br>2.Java支持多层继承（继承体系）</p>\n<pre class=\"line-numbers language-Java\" data-language=\"Java\"><code class=\"language-Java\">class GrandFather&#123;\n\tpublic void show() &#123;\n\t\tSystem.out.println(&quot;爷爷&quot;);\n\t&#125;\n&#125;\nclass Father extends GrandFather&#123;\n\tpublic void show1() &#123;\n\t\tSystem.out.println(&quot;爸爸&quot;);\n\t&#125;\n&#125;\nclass Son extends Father&#123;\n\tpublic void show2() &#123;\n\t\tSystem.out.println(&quot;儿子&quot;);\n\t&#125;\n&#125;\npublic static void main(String[] args)&#123;\n\tSon s &#x3D; new Son();\n\ts.show();&#x2F;&#x2F;爷爷\n\ts.show1();&#x2F;&#x2F;爸爸\n\ts.show2();&#x2F;&#x2F;儿子\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h2 id=\"继承的注意事项\"><a href=\"#继承的注意事项\" class=\"headerlink\" title=\"继承的注意事项\"></a>继承的注意事项</h2><p>1.子类只能继承父类所有非私有的成员(成员方法和成员变量)<br>2.子类不能继承父类的构造方法，但是可以通过super关键字去访问父类的构造方法。<br>3.不要为了部分功能而去继承</p>\n<pre><code>class A&#123;\n    public void show1()&#123;&#125;\n    public void show2()&#123;&#125;\n&#125;\nclass B&#123;\n    public void show2()&#123;&#125;\n    public void show3()&#123;&#125;\n&#125;\n\n    class B extends A&#123;\n    public void show3()&#123;&#125;\n&#125;//这样做不好多出了show1\n</code></pre>\n<h2 id=\"何时用继承\"><a href=\"#何时用继承\" class=\"headerlink\" title=\"何时用继承\"></a>何时用继承</h2><p>假设法:<br>如果有两个类A,B.只有他们符合A是B的一种,或者B是A的一种,就可以考虑使用继承.<br>eg:<br>A:水果<br>B:苹果<br>苹果 extends 水果</p>\n<h2 id=\"继承中的关系\"><a href=\"#继承中的关系\" class=\"headerlink\" title=\"继承中的关系\"></a>继承中的关系</h2><h3 id=\"继承中成员变量的关系\"><a href=\"#继承中成员变量的关系\" class=\"headerlink\" title=\"继承中成员变量的关系\"></a>继承中成员变量的关系</h3><p>A:子类中的成员变量和父类中的成员变量名称不一样,直接继承.<br>B:子类中的成员变量和父类中的成员变量名称一样,就近原则.<br>结论:<br>在子类方法中访问一个变量<br>1.首先在子类局部范围找<br>2.然后再子类成员范围找<br>3.最后在父类成员范围找(肯定不能访问到父类局部范围)<br>4.如果还是没有就报错(不考虑父类的父类.)</p>\n<h3 id=\"继承中构造方法的关系\"><a href=\"#继承中构造方法的关系\" class=\"headerlink\" title=\"继承中构造方法的关系\"></a>继承中构造方法的关系</h3><p>A:子类中所有的构造方法默认都会访问父类中空参数的构造方法<br>B:A为什么?<br>因为子类会继承父类中的数据，可能会使用父类的数据。所以，子类初始化之前，一定要先完成父类数据的初始化。<br>子类每一个构造方法的第一条语句默认都是：super()</p>\n<h4 id=\"继承中构造方法的注意事项\"><a href=\"#继承中构造方法的注意事项\" class=\"headerlink\" title=\"继承中构造方法的注意事项\"></a>继承中构造方法的注意事项</h4><p>如果父类没有无参构造方法,那么子类的构造方法会报错.<br>解决方法:<br>1.在父类中加一个无参构造方法<br>2.通过使用super关键字去显示的调用父类的带参构造方法<br>3.子类通过this去调用本类的其他构造方法，子类中一定要有一个去访问父类的构造方法，否则父类数据就没有初始化。<br>注意事项：<br>this(…)或者super(…)必须出现在第一条语句上。<br>如果没有放在第一条语句上，就可能对父类的数据进行了多次初始化，所以必须放在第一条语句上。</p>\n<h3 id=\"继承中成员方法的关系\"><a href=\"#继承中成员方法的关系\" class=\"headerlink\" title=\"继承中成员方法的关系\"></a>继承中成员方法的关系</h3><p>A:子类中的方法和父类中的方法声明不一样,直接继承.<br>B:子类中的方法和父类中的方法声明一样,就近原则.<br>通过子类对象调用方法:<br>1.先找子类中,看有没有这个方法,有就使用.<br>2.再看父类中,有没有这个方法,有就使用.<br>3.如果没有就报错.</p>\n<h2 id=\"this和super的区别\"><a href=\"#this和super的区别\" class=\"headerlink\" title=\"this和super的区别\"></a>this和super的区别</h2><p>super的用法和this很像：<br>this代表本类对应的引用<br>super代表父类存储空间的标识(可以理解为父类引用，可以操作父类的成员)<br>用法：<br>1.调用成员变量</p>\n<pre><code>this.成员变量 //调用本类的成员变量\nsuper.成员变量 //调用父类的成员变量\n</code></pre>\n<p>2.调用成员方法</p>\n<pre><code>this(...) //调用子类的构造方法\nsuper(...) //调用父类的构造方法\n</code></pre>\n<p>3.调用成员方法</p>\n<pre><code>this.成员方法 //调用子类的成员方法\nsuper.成员方法 //调用父类的成员方法\n</code></pre>\n<h2 id=\"初始化流程\"><a href=\"#初始化流程\" class=\"headerlink\" title=\"初始化流程\"></a>初始化流程</h2><p><img src=\"/img/%E5%88%9D%E5%A7%8B%E5%8C%96%E6%B5%81%E7%A8%8B.png\"></p>\n<h3 id=\"问题\"><a href=\"#问题\" class=\"headerlink\" title=\"问题\"></a>问题</h3><p><img src=\"/img/%E5%AD%90%E7%B1%BB%E5%88%9D%E5%A7%8B%E5%8C%96%E9%97%AE%E9%A2%98.png\"></p>\n<h2 id=\"方法重写-override\"><a href=\"#方法重写-override\" class=\"headerlink\" title=\"方法重写(override)\"></a>方法重写(override)</h2><p>方法重写：子类中出现了和父类中方法声明一模一样的方法，也被称位方法覆盖，方法复写。<br>使用特点：<br>如果方法名不同，有就调用对应的方法<br>如果方法名相同，最终使用的是子类自己的<br>应用:<br>当子类需要父类的功能，而功能主题子类有自己特有内容时，可以重写父类中的方法，这样，即沿袭了父类的功能，有定义了子类特有的内容。</p>\n<pre class=\"line-numbers language-Java\" data-language=\"Java\"><code class=\"language-Java\">public class Phone&#123;\n\tpublic void call(String name)&#123;\n\t\tSystem.out.println(&quot;给&quot; + name + &quot;打电话&quot;);\n\t&#125;\n&#125;\npublic class NewPhone&#123;\n\tpublic void call(String name)&#123;\n\t\t&#x2F;&#x2F;System.out.println(&quot;给&quot; + name + &quot;打电话&quot;);\n\t\tsuper.call(name);\n\t\tSystem.out.println(&quot;看天气预报&quot;);\n\t&#125;\n&#125;\n\npublic class CallPhone&#123;\n\tpublic static void main(String[] args)&#123;\n\t\tNewPhone np &#x3D; new NewPhone();\n\t\tnp.call(&quot;胖虎&quot;);\n\t&#125;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>注意事项：<br>1.父类中私有方法不能被重写 (父类私有子类根本无法继承)<br>2.子类重写父类方法时，访问权限不能太低<br>3.父类静态方法，子类也必须通过静态方法进行重写。(算不上重写，但是现象是重写)</p>\n<p>子类重写父类方法的时候，最好声明一模一样</p>\n<h2 id=\"关键字final\"><a href=\"#关键字final\" class=\"headerlink\" title=\"关键字final\"></a>关键字final</h2><p>由于继承中方法有一个现象：方法重写。<br>所以，父类的功能，就会被子类给覆盖掉。<br>有时不想让子类覆盖父类的功能，只能提供给子类使用。<br>就可以用final关键字。</p>\n<p>final：最终的意思。可以修饰类，方法，变量。</p>\n<p>特点：<br>1.final可以修饰类，该类不能被继承。<br>2.final可以修饰方法，该方法不能被重写。（覆盖，复写）<br>3.final可以修饰变量，该变量不能被重新赋值。因为这个变量其实是常量。</p>\n<p>常量：<br>A：字面常量：”hello”,10,true<br>B：自定义常量：final int x = 10;</p>\n<h3 id=\"final修饰局部变量的问题\"><a href=\"#final修饰局部变量的问题\" class=\"headerlink\" title=\"final修饰局部变量的问题\"></a>final修饰局部变量的问题</h3><p>基本类型:基本类型的值不能发生改变.<br>引用类型:引用类型的地址值不能发生改变,但是,该对象的堆内存的值是可以改变的</p>\n<h3 id=\"final修饰变量的初始化时机\"><a href=\"#final修饰变量的初始化时机\" class=\"headerlink\" title=\"final修饰变量的初始化时机\"></a>final修饰变量的初始化时机</h3><p>A:被final修饰的变量只能赋值一次.<br>B:在构造方法完毕前.(非静态的常量)</p>\n<h2 id=\"多态\"><a href=\"#多态\" class=\"headerlink\" title=\"多态\"></a>多态</h2><h3 id=\"多态概述\"><a href=\"#多态概述\" class=\"headerlink\" title=\"多态概述\"></a>多态概述</h3><pre><code>某一个事物,在不同时刻表现出来的不同状态.\n</code></pre>\n<p>举例:<br>猫可以是猫的类型.猫 m = new 猫();<br>同时猫也是动物的一种,也可以把猫称为动物.动物 d = new 猫();<br>水(液态,固态,气态)</p>\n<h3 id=\"多态的前提\"><a href=\"#多态的前提\" class=\"headerlink\" title=\"多态的前提:\"></a>多态的前提:</h3><p>1.要有继承关系.<br>2.要有方法重写.(其实没有也是可以的,但是如果没有这个就没有意义)<br>3.要有父类引用指向子类对象. 父 f = new 子();</p>\n<h3 id=\"多态中的成员访问特点\"><a href=\"#多态中的成员访问特点\" class=\"headerlink\" title=\"多态中的成员访问特点:\"></a>多态中的成员访问特点:</h3><p>A:成员变量(编译看左边,运行看右边.)<br>B:构造方法(创建子类对象的时候,访问父类的构造方法,对父类的数据进行初始化.)<br>C:成员方法(编译看左边,运行看右边.方法存在复写,就显示子类的成员方法.)<br>D:静态方法(编译看左边,运行看左边.{静态和类相关,算不上重写.所以访问的还是左边})</p>\n<p>由于成员方法存在方法重写,所以它运行看右边.</p>\n<h3 id=\"多态的好处\"><a href=\"#多态的好处\" class=\"headerlink\" title=\"多态的好处\"></a>多态的好处</h3><p>1.提高了代码的维护性(继承保证)<br>2.提高了代码的扩展性(由多态保证)</p>\n<h3 id=\"多态的弊端\"><a href=\"#多态的弊端\" class=\"headerlink\" title=\"多态的弊端\"></a>多态的弊端</h3><p>不能使用子类的特有功能</p>\n<h3 id=\"多态的向下转型和向上转型\"><a href=\"#多态的向下转型和向上转型\" class=\"headerlink\" title=\"多态的向下转型和向上转型\"></a>多态的向下转型和向上转型</h3><p>向上转型：</p>\n<pre><code>Fu f = new Zi();\n</code></pre>\n<p>向下转型：</p>\n<pre><code>Zi z = (Zi)f;//要求该f必须是能够转换为Zi的.\n</code></pre>\n<h3 id=\"多态内存图解\"><a href=\"#多态内存图解\" class=\"headerlink\" title=\"多态内存图解\"></a>多态内存图解</h3><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>多态继承中的内存图解</p></blockquote>\n<p><img src=\"/img/%E7%BB%A7%E6%89%BF%E5%A4%9A%E6%80%81%E5%9B%BE%E8%A7%A3.png\"></p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>多态中的对象变化内存图解</p></blockquote>\n<p><img src=\"/img/%E5%AF%B9%E8%B1%A1%E5%8F%98%E5%8C%96%E5%86%85%E5%AD%98%E5%9B%BE.png\"></p>\n<p>ClassCastException：类型转换异常<br>一般在多态的向下转型中容易出现</p>\n","text":"概述多个类中存在相同属性和行为时，将这些内容抽取到单独一个类中，那么多个类无需再定义这些属性和行为，只要继承那个类即可。通过extends关键字可以实现类与类的继承 class 子类名 extends父类名&#123;&#125; 单独的这个类成为父类，基类或者超类；这多个类可以...","link":"","photos":[],"count_time":{"symbolsCount":"4k","symbolsTime":"4 mins."},"categories":[{"name":"Java","slug":"Java","count":22,"path":"api/categories/Java.json"}],"tags":[{"name":"Java学习总结","slug":"Java学习总结","count":21,"path":"api/tags/Java学习总结.json"},{"name":"面向对象","slug":"面向对象","count":7,"path":"api/tags/面向对象.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%A6%82%E8%BF%B0\"><span class=\"toc-text\">概述</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Java%E4%B8%AD%E7%BB%A7%E6%89%BF%E7%9A%84%E7%89%B9%E7%82%B9\"><span class=\"toc-text\">Java中继承的特点</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%BB%A7%E6%89%BF%E7%9A%84%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9\"><span class=\"toc-text\">继承的注意事项</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%BD%95%E6%97%B6%E7%94%A8%E7%BB%A7%E6%89%BF\"><span class=\"toc-text\">何时用继承</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%BB%A7%E6%89%BF%E4%B8%AD%E7%9A%84%E5%85%B3%E7%B3%BB\"><span class=\"toc-text\">继承中的关系</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%BB%A7%E6%89%BF%E4%B8%AD%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%E7%9A%84%E5%85%B3%E7%B3%BB\"><span class=\"toc-text\">继承中成员变量的关系</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%BB%A7%E6%89%BF%E4%B8%AD%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95%E7%9A%84%E5%85%B3%E7%B3%BB\"><span class=\"toc-text\">继承中构造方法的关系</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E7%BB%A7%E6%89%BF%E4%B8%AD%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95%E7%9A%84%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9\"><span class=\"toc-text\">继承中构造方法的注意事项</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%BB%A7%E6%89%BF%E4%B8%AD%E6%88%90%E5%91%98%E6%96%B9%E6%B3%95%E7%9A%84%E5%85%B3%E7%B3%BB\"><span class=\"toc-text\">继承中成员方法的关系</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#this%E5%92%8Csuper%E7%9A%84%E5%8C%BA%E5%88%AB\"><span class=\"toc-text\">this和super的区别</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%88%9D%E5%A7%8B%E5%8C%96%E6%B5%81%E7%A8%8B\"><span class=\"toc-text\">初始化流程</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E9%97%AE%E9%A2%98\"><span class=\"toc-text\">问题</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%96%B9%E6%B3%95%E9%87%8D%E5%86%99-override\"><span class=\"toc-text\">方法重写(override)</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%85%B3%E9%94%AE%E5%AD%97final\"><span class=\"toc-text\">关键字final</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#final%E4%BF%AE%E9%A5%B0%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E7%9A%84%E9%97%AE%E9%A2%98\"><span class=\"toc-text\">final修饰局部变量的问题</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#final%E4%BF%AE%E9%A5%B0%E5%8F%98%E9%87%8F%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E6%97%B6%E6%9C%BA\"><span class=\"toc-text\">final修饰变量的初始化时机</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%A4%9A%E6%80%81\"><span class=\"toc-text\">多态</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%A4%9A%E6%80%81%E6%A6%82%E8%BF%B0\"><span class=\"toc-text\">多态概述</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%A4%9A%E6%80%81%E7%9A%84%E5%89%8D%E6%8F%90\"><span class=\"toc-text\">多态的前提:</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%A4%9A%E6%80%81%E4%B8%AD%E7%9A%84%E6%88%90%E5%91%98%E8%AE%BF%E9%97%AE%E7%89%B9%E7%82%B9\"><span class=\"toc-text\">多态中的成员访问特点:</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%A4%9A%E6%80%81%E7%9A%84%E5%A5%BD%E5%A4%84\"><span class=\"toc-text\">多态的好处</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%A4%9A%E6%80%81%E7%9A%84%E5%BC%8A%E7%AB%AF\"><span class=\"toc-text\">多态的弊端</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%A4%9A%E6%80%81%E7%9A%84%E5%90%91%E4%B8%8B%E8%BD%AC%E5%9E%8B%E5%92%8C%E5%90%91%E4%B8%8A%E8%BD%AC%E5%9E%8B\"><span class=\"toc-text\">多态的向下转型和向上转型</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%A4%9A%E6%80%81%E5%86%85%E5%AD%98%E5%9B%BE%E8%A7%A3\"><span class=\"toc-text\">多态内存图解</span></a></li></ol></li></ol>","author":{"name":"Allen Yang","slug":"blog-author","avatar":"/img/i3.jpg","link":"/","description":"记录学习中的点点滴滴","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"抽象类","uid":"166ef0124d1706b7cbddeea81ab00167","slug":"抽象类","date":"2018-12-09T01:34:55.000Z","updated":"2019-04-05T01:05:11.000Z","comments":true,"path":"api/articles/抽象类.json","keywords":null,"cover":null,"text":"抽象类概括在Java中，一个没有方法体的方法应该定义为抽象方法，而类中如果有抽象方法，该类必须定义为抽象类。 抽象类的特点1.抽象类和抽象方法必须用abstract关键字修饰 格式 abstract class 类名{} public abstract void eat(); 2...","link":"","photos":[],"count_time":{"symbolsCount":630,"symbolsTime":"1 mins."},"categories":[{"name":"Java","slug":"Java","count":22,"path":"api/categories/Java.json"}],"tags":[{"name":"Java学习总结","slug":"Java学习总结","count":21,"path":"api/tags/Java学习总结.json"},{"name":"面向对象","slug":"面向对象","count":7,"path":"api/tags/面向对象.json"}],"author":{"name":"Allen Yang","slug":"blog-author","avatar":"/img/i3.jpg","link":"/","description":"记录学习中的点点滴滴","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"代码块","uid":"efa8c010c59ff382983a4c1b80223f3a","slug":"代码块","date":"2018-12-07T02:42:11.000Z","updated":"2019-04-05T01:04:38.000Z","comments":true,"path":"api/articles/代码块.json","keywords":null,"cover":null,"text":"代码块在Java中，使用{}括起来的代码被称为代码块，根据其位置和声明的不同，可以分为局部代码块，构造代码块，静态代码块，同步代码块。 局部代码块在方法中出现；限定变量生命周期，及早释放，提高内存利用率。 public static void main(String[] args...","link":"","photos":[],"count_time":{"symbolsCount":"1.7k","symbolsTime":"2 mins."},"categories":[{"name":"Java","slug":"Java","count":22,"path":"api/categories/Java.json"}],"tags":[{"name":"Java学习总结","slug":"Java学习总结","count":21,"path":"api/tags/Java学习总结.json"},{"name":"面向对象","slug":"面向对象","count":7,"path":"api/tags/面向对象.json"}],"author":{"name":"Allen Yang","slug":"blog-author","avatar":"/img/i3.jpg","link":"/","description":"记录学习中的点点滴滴","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}